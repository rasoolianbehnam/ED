from ctypes import *
import sys

import string

def hexdump(src, length=16, sep='.'):
    DISPLAY = string.digits + string.letters + string.punctuation
    FILTER = ''.join(((x if x in DISPLAY else '.') for x in map(chr, range(256))))
    lines = []
    for c in xrange(0, len(src), length):
        chars = src[c:c+length] 
        hex = ' '.join(["%02x" % ord(x) for x in chars])
        if len(hex) > 24:
            hex = "%s %s" % (hex[:24], hex[24:])
        printable = ''.join(["%s" % FILTER[ord(x)] for x in chars])
        lines.append("%08x:  %-*s  |%s|\n" % (c, length*3, hex, printable))
    print ''.join(lines)

class pcap_pkthdr(Structure):
    _fields_ = [
            ('ts'       , c_char * 16),
            ('caplen'   , c_uint32),
            ('len'      , c_uint32)
            ]

class IP(Structure):
    _fields_ = [
            ("ihl",         c_ubyte, 4),
            ("version",     c_ubyte, 4),
            ("tos",         c_ubyte),
            ("len",         c_ushort),
            ("id",          c_ushort),
            ("offset",      c_ushort),
            ("ttl",         c_ubyte),
            ("protocol_num",c_ubyte),
            ("sum",         c_ushort),
            ("src",         c_uint32),
            ("dst",         c_uint32)
            ]
    def __new__(self, socket_buffer=None):
        return self.from_buffer_copy(socket_buffer)

    def __init__(self, socket_buffer=None):
        self.protocol_map = {1:"ICMP", 6:"TCP", 17:"UDP"}
        self.src_address = socket.inet_ntoa(struct.pack("@I",self.src))
        self.dst_address = socket.inet_ntoa(struct.pack("@I",self.dst))


libpcap = CDLL('libpcap.so')
errbuf = (c_char * 256)()
header = pcap_pkthdr()
print(sizeof(header))
pcap_lookupdev = libpcap.pcap_lookupdev
pcap_lookupdev.restype = c_char_p
device = pcap_lookupdev(errbuf)
if not device:
    print(errbuf)
    sys.exit(0)
print("using device %s"%device)
pcap_open_live = libpcap.pcap_open_live
pcap_open_live.restype = c_void_p
pcap_handle = pcap_open_live(device, 4096, 1, 0, errbuf)
if not pcap_handle:
    print("pcap_open_live: %s"%errbuf.value);
    sys.exit(0)
pcap_next = libpcap.pcap_next
pcap_next.restype = c_char_p
pcap_next.argtype = [c_void_p, pcap_pkthdr]
for i in range(3):
    packet = pcap_next(pcap_handle, byref(header))
    print "Got a %d byte packet"%header.len
    hexdump(packet, int(header.len))

pcap_close = libpcap.pcap_close
pcap_close.argstype = [c_void_p]
pcap_close(pcap_handle)
