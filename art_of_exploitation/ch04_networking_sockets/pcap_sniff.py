from ctypes import *
import sys

import string

def hexdump(src, length=16, sep='.'):
    DISPLAY = string.digits + string.letters + string.punctuation
    FILTER = ''.join(((x if x in DISPLAY else '.') for x in map(chr, range(256))))
    lines = []
    for c in xrange(0, len(src), length):
        chars = src[c:c+length] 
        hex = ' '.join(["%02x" % ord(x) for x in chars])
        if len(hex) > 24:
            hex = "%s %s" % (hex[:24], hex[24:])
        printable = ''.join(["%s" % FILTER[ord(x)] for x in chars])
        lines.append("%08x:  %-*s  |%s|\n" % (c, length*3, hex, printable))
    print ''.join(lines)

class pcap_pkthdr(Structure):
    _fields_ = [
            ('ts'       , c_char * 16),
            ('caplen'   , c_uint32),
            ('len'      , c_uint32)
            ]

libpcap = CDLL('libpcap.so')
errbuf = (c_char * 256)()
header = pcap_pkthdr()
print(sizeof(header))
pcap_lookupdev = libpcap.pcap_lookupdev
pcap_lookupdev.restype = c_char_p
device = pcap_lookupdev(errbuf)
if not device:
    print(errbuf)
    sys.exit(0)
print("using device %s"%device)
pcap_open_live = libpcap.pcap_open_live
pcap_open_live.restype = c_void_p
pcap_handle = pcap_open_live(device, 4096, 1, 0, errbuf)
if not pcap_handle:
    print("pcap_open_live: %s"%errbuf.value);
    sys.exit(0)
pcap_next = libpcap.pcap_next
pcap_next.restype = c_char_p
pcap_next.argtype = [c_void_p, pcap_pkthdr]
for i in range(3):
    packet = pcap_next(pcap_handle, byref(header))
    print "Got a %d byte packet"%header.len
    hexdump(packet, int(header.len))

pcap_close = libpcap.pcap_close
pcap_close.argstype = [c_void_p]
pcap_close(pcap_handle)
