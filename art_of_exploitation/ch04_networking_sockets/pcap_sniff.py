from ctypes import *
import sys
import dpkt
import socket
import struct
from scapy.all import *

import string

def hexdump(src, len_src, length=16, sep='.'):
    DISPLAY = string.digits + string.letters + string.punctuation
    FILTER = ''.join(((x if x in DISPLAY else '.') for x in map(chr, range(256))))
    lines = []
    for c in xrange(0, len_src, length):
        chars = src[c:c+length] 
        hex = ' '.join(["%02x" % ord(x) for x in chars])
        if len(hex) > 24:
            hex = "%s %s" % (hex[:24], hex[24:])
        printable = ''.join(["%s" % FILTER[ord(x)] for x in chars])
        lines.append("%08x:  %-*s  |%s|\n" % (c, length*3, hex, printable))
    print ''.join(lines)

class IP(Structure):
    _fields_ = [
            ("ihl",         c_ubyte, 4),
            ("version",     c_ubyte, 4),
            ("tos",         c_ubyte),
            ("len",         c_ushort),
            ("id",          c_ushort),
            ("offset",      c_ushort),
            ("ttl",         c_ubyte),
            ("protocol_num",c_ubyte),
            ("sum",         c_ushort),
            ("src",         c_uint32),
            ("dst",         c_uint32)
            ]
    def __new__(self, socket_buffer=None):
        return self.from_buffer_copy(socket_buffer)

    def __init__(self, socket_buffer=None):
        self.protocol_map = {1:"ICMP", 6:"TCP", 17:"UDP"}
        self.src_address = socket.inet_ntoa(struct.pack("@I",self.src))
        self.dst_address = socket.inet_ntoa(struct.pack("@I",self.dst))

        try:
            self.protocol= self.protocol_map[self.protocol_num]
        except:
            self.protocol = str(self.protocol_num)

class pcap_pkthdr(Structure):
    _fields_ = [
            ('ts'       , c_char * 16),
            ('caplen'   , c_uint32),
            ('len'      , c_uint32)
            ]

class IP(Structure):
    _fields_ = [
            ("ihl",         c_ubyte, 4),
            ("version",     c_ubyte, 4),
            ("tos",         c_ubyte),
            ("len",         c_ushort),
            ("id",          c_ushort),
            ("offset",      c_ushort),
            ("ttl",         c_ubyte),
            ("protocol_num",c_ubyte),
            ("sum",         c_ushort),
            ("src",         c_uint32),
            ("dst",         c_uint32)
            ]
    def __new__(self, socket_buffer=None):
        return self.from_buffer_copy(socket_buffer)

    def __init__(self, socket_buffer=None):
        self.protocol_map = {1:"ICMP", 6:"TCP", 17:"UDP"}
        self.src_address = socket.inet_ntoa(struct.pack("@I",self.src))
        self.dst_address = socket.inet_ntoa(struct.pack("@I",self.dst))
class ether_hdr(Structure):
    _fields_ = [
            ('ether_dst_address' , c_ubyte * 6),
            ('ether_src_address' , c_ubyte * 6),
            ('ether_type'        , c_uint16)
            ]
    def __new__(self, buffer=None):
        return self.from_buffer_copy(buffer)
    def __init__(self, buffer=None):
        self.src_address = ''
        self.dst_address = ''
        a = cast(self.ether_src_address, POINTER(c_char))
        b = cast(self.ether_dst_address, POINTER(c_char))
        for i in range(6):
            byte = a[i]
            self.src_address += ":%02x"%ord(byte)
            byte = b[i]
            self.dst_address += ":%02x"%ord(byte)


libpcap = CDLL('libpcap.so')
errbuf = (c_char * 256)()
header = pcap_pkthdr()
print(sizeof(header))
pcap_lookupdev = libpcap.pcap_lookupdev
pcap_lookupdev.restype = c_char_p
device = pcap_lookupdev(errbuf)
if not device:
    print(errbuf)
    sys.exit(0)
print("using device %s"%device)
pcap_open_live = libpcap.pcap_open_live
pcap_open_live.restype = c_void_p
pcap_handle = pcap_open_live(device, 4096, 1, 0, errbuf)
if not pcap_handle:
    print("pcap_open_live: %s"%errbuf.value);
    sys.exit(0)

pcap_next = libpcap.pcap_next
pcap_next.restype = c_char_p
pcap_next.argtype = [c_void_p, pcap_pkthdr]
for i in range(3):
    print i
    packet = pcap_next(pcap_handle, byref(header))
    print "Got a %d byte packet"%header.len
    hexdump(packet, int(header.len))

#how to dereference pointer to structures
#address = '192.168.0.107'
#def mardas(args, header, packet):
#    print("mardas")
#    packet = Ether(packet[:header.contents.len])
#    packet.show()
#    #eth = ether_hdr(packet[:14])
#    #ip = IP(packet[14:14+20])
#    #if ip.src_address == address or ip.dst_address == address:
#    #    print "Got a %d byte packet"%header.contents.len
#    #    print("%s -> %s"%(eth.src_address, eth.dst_address))
#    #    print("%s -> %s"%(ip.src_address, ip.dst_address))
#    #    print('**********************')
#    
#    #hexdump(packet, int(header.contents.len))
#    #print packet
#
#print("mardas e raghas")
#print("a = 0x%x"%pcap_handle)
##creating callback functions
##the first argument is return value
#call_back = CFUNCTYPE(None, c_char_p, POINTER(pcap_pkthdr), POINTER(c_char))(mardas)
##pcap_loop = libpcap.pcap_loop
##pcap_loop.argtype = [c_void_p, c_int32, c_void_p, c_char_p]
#libpcap.pcap_loop(pcap_handle, 3, call_back, None)
#print("a = 0x%x"%pcap_handle)
#for i in range(3):
#    packet = libpcap.pcap_next(pcap_handle, POINTER(
pcap_close = libpcap.pcap_close
pcap_close.argstype = [c_void_p]
pcap_close(pcap_handle)
